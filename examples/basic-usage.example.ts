import { Test } from '@nestjs/testing';
import { PrismaClient } from '@prisma/client';
import {
  TestDatabaseDecorator,
  createTestApp,
  getTestDatabase,
  WithTransaction,
  DatabaseSeeder,
  TestAppConfig
} from '../src';

// Example entities/models (would be generated by Prisma)
interface User {
  id: number;
  email: string;
  name: string;
  createdAt: Date;
}

interface Post {
  id: number;
  title: string;
  content: string;
  authorId: number;
  createdAt: Date;
}

// Example service that would exist in your NestJS app
class UserService {
  constructor(private prisma: PrismaClient) {}

  async createUser(data: { email: string; name: string }): Promise<User> {
    return this.prisma.user.create({ data }) as any;
  }

  async findUserById(id: number): Promise<User | null> {
    return this.prisma.user.findUnique({ where: { id } }) as any;
  }

  async getAllUsers(): Promise<User[]> {
    return this.prisma.user.findMany() as any;
  }
}

class PostService {
  constructor(private prisma: PrismaClient) {}

  async createPost(data: { title: string; content: string; authorId: number }): Promise<Post> {
    return this.prisma.post.create({ data }) as any;
  }

  async getPostsByUser(authorId: number): Promise<Post[]> {
    return this.prisma.post.findMany({ where: { authorId } }) as any;
  }
}

// Example seeder
class UserSeeder implements DatabaseSeeder {
  name = 'users';
  dependencies = [];

  async seed(client: PrismaClient): Promise<void> {
    await client.user.createMany({
      data: [
        { email: 'john@example.com', name: 'John Doe' },
        { email: 'jane@example.com', name: 'Jane Smith' },
        { email: 'bob@example.com', name: 'Bob Johnson' },
      ],
    });
  }
}

class PostSeeder implements DatabaseSeeder {
  name = 'posts';
  dependencies = ['users']; // Depends on users being created first

  async seed(client: PrismaClient): Promise<void> {
    const users = await client.user.findMany();
    
    await client.post.createMany({
      data: [
        {
          title: 'First Post',
          content: 'This is the first post',
          authorId: users[0].id,
        },
        {
          title: 'Second Post', 
          content: 'This is the second post',
          authorId: users[1].id,
        },
      ],
    });
  }
}

// Example 1: Using the decorator approach
@TestDatabaseDecorator({
  applyMigrations: true,
  cleanup: 'truncate',
  logging: false,
})
describe('UserService with @TestDatabase', () => {
  let userService: UserService;
  let prisma: PrismaClient;

  beforeEach(async () => {
    const testDb = getTestDatabase();
    prisma = testDb.getClient();
    userService = new UserService(prisma);

    // Seed data for each test
    const userSeeder = new UserSeeder();
    await userSeeder.seed(prisma);
  });

  it('should create a new user', async () => {
    const user = await userService.createUser({
      email: 'test@example.com',
      name: 'Test User',
    });

    expect(user.email).toBe('test@example.com');
    expect(user.name).toBe('Test User');
    expect(user.id).toBeDefined();
  });

  it('should find user by id', async () => {
    const users = await userService.getAllUsers();
    const firstUser = users[0];

    const foundUser = await userService.findUserById(firstUser.id);
    
    expect(foundUser).toBeDefined();
    expect(foundUser!.email).toBe('john@example.com');
  });
});

// Example 2: Using the createTestApp approach  
describe('Full NestJS Integration', () => {
  let app: any;
  let userService: UserService;
  let postService: PostService;

  beforeEach(async () => {
    const config: TestAppConfig = {
      providers: [UserService, PostService],
      seed: [new UserSeeder(), new PostSeeder()], // Auto-seeding
      databaseConfig: {
        applyMigrations: true,
        cleanup: 'truncate',
      },
    };

    app = await createTestApp(config);
    userService = app.get<UserService>(UserService);
    postService = app.get<PostService>(PostService);
  });

  afterEach(async () => {
    await app.close();
  });

  it('should create post for existing user', async () => {
    const users = await userService.getAllUsers();
    const user = users[0];

    const post = await postService.createPost({
      title: 'Test Post',
      content: 'This is a test post',
      authorId: user.id,
    });

    expect(post.title).toBe('Test Post');
    expect(post.authorId).toBe(user.id);
  });

  it('should get posts by user', async () => {
    const users = await userService.getAllUsers();
    const user = users[0];

    const posts = await postService.getPostsByUser(user.id);
    
    expect(posts.length).toBeGreaterThan(0);
    expect(posts[0].authorId).toBe(user.id);
  });
});

// Example 3: Transaction-based isolation
@TestDatabaseDecorator({
  applyMigrations: true,
  cleanup: 'transaction', // Use transaction cleanup
})
describe('Transaction-based Tests', () => {
  let userService: UserService;
  let prisma: PrismaClient;

  beforeEach(async () => {
    const testDb = getTestDatabase();
    prisma = testDb.getClient();
    userService = new UserService(prisma);
  });

  @WithTransaction()
  it('should rollback changes after test', async () => {
    // This test runs in a transaction that gets rolled back
    await userService.createUser({
      email: 'rollback@example.com',
      name: 'Rollback User',
    });

    const users = await userService.getAllUsers();
    expect(users.length).toBe(1);
    
    // After this test, the user will be rolled back
  });

  @WithTransaction()
  it('should not see data from previous test', async () => {
    // This test should not see the user created in the previous test
    const users = await userService.getAllUsers();
    expect(users.length).toBe(0);
  });
});

// Example 4: Custom seeding function
describe('Custom Seeding', () => {
  let app: any;
  let userService: UserService;

  beforeEach(async () => {
    app = await createTestApp({
      providers: [UserService],
      seed: async (client: PrismaClient) => {
        // Custom seeding logic
        await client.user.create({
          data: {
            email: 'custom@example.com',
            name: 'Custom User',
          },
        });
      },
    });

    userService = app.get<UserService>(UserService);
  });

  afterEach(async () => {
    await app.close();
  });

  it('should have custom seeded data', async () => {
    const users = await userService.getAllUsers();
    
    expect(users.length).toBe(1);
    expect(users[0].email).toBe('custom@example.com');
  });
}); 